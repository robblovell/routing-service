// Generated by CoffeeScript 1.10.0
(function() {
  var async, combyne, iGraphRepository, neo4j, uuid,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  async = require('async');

  iGraphRepository = require('./iGraphRepository');

  combyne = require('combyne');

  neo4j = require('neo4j-driver').v1;

  uuid = require('uuid');

  module.exports = iGraphRepository = (function() {
    var makeQuery;

    function iGraphRepository(config) {
      this.config = config;
      this.exec = bind(this.exec, this);
      this.set = bind(this.set, this);
      this.setEdge = bind(this.setEdge, this);
      this.buffer = null;
      if (this.config.url == null) {
        this.config.url = 'bolt://neo4j:macro7@localhost';
      }
      if (this.config.url.indexOf(':') > -1 && this.config.url.indexOf('@') > -1) {
        this.config.user = this.config.url.split("//")[1].split(":")[0];
        this.config.pass = this.config.url.split("//")[1].split("@")[0].split(":")[1];
        this.config.url = this.config.url.replace(this.config.user + ":" + this.config.pass + "@", "");
      }
      this.neo4j = neo4j.driver(this.config.url, neo4j.auth.basic(this.config.user, this.config.pass));
      return;
    }

    iGraphRepository.prototype.find = function(example, callback) {
      var cypher;
      cypher = "Match (n:" + example.type + ") RETURN n";
      return this.run(cypher, {}, callback);
    };

    iGraphRepository.prototype.run = function(cypher, data, callback) {
      var session;
      if (callback == null) {
        callback = null;
      }
      if ((this.buffer != null) || (callback == null)) {
        this.buffer.run(cypher, data);
      } else {
        session = this.neo4j.session();
        session.run(cypher, data).then((function(_this) {
          return function(result) {
            var i, j, len, len1, record, ref, ref1, results;
            session.close();
            if (result && result.records.length > 0) {
              if (result.records[0] && (result.records[0].toObject != null) && result.records[0].toObject().n && result.records[0].toObject().n.properties) {
                results = [];
                ref = result.records;
                for (i = 0, len = ref.length; i < len; i++) {
                  record = ref[i];
                  results.push(record.toObject().n.properties);
                }
                callback(null, results);
              } else {
                results = [];
                ref1 = result.records;
                for (j = 0, len1 = ref1.length; j < len1; j++) {
                  record = ref1[j];
                  results.push(record.toObject());
                }
                callback(null, results);
              }
            } else {
              callback(null, "[]");
            }
          };
        })(this))["catch"]((function(_this) {
          return function(error) {
            console.log("Error:" + error);
            session.close();
            callback(error, null);
          };
        })(this));
      }
    };

    iGraphRepository.prototype.get = function(example, callback) {
      var cypher;
      if (example.id === "" || example.id === null) {
        callback(null, "{}");
        return;
      }
      cypher = "MATCH (n:" + example.type + ") WHERE n.id = {id} RETURN n";
      console.log("Cypher: " + cypher);
      return this.run(cypher, example, callback);
    };

    makeQuery = function(query, type) {
      var example, k, paging, queryStr, v;
      paging = "";
      if ((query.skip != null) && (query.limit != null)) {
        paging += " SKIP " + query.skip;
      }
      if (query.limit != null) {
        paging += " LIMIT " + query.limit;
      }
      queryStr = "";
      if (query.query != null) {
        queryStr = " WHERE ";
        example = JSON.parse(query.query);
        if (typeof example === 'string') {
          queryStr = " WHERE " + example;
        } else {
          for (k in example) {
            v = example[k];
            if (typeof v === 'string') {
              queryStr += type + "." + k + "='" + v + "' and ";
            } else {
              queryStr += type + "." + k + "=" + v + " and ";
            }
          }
          queryStr = queryStr.slice(0, -5);
        }
      }
      return [queryStr, paging];
    };

    iGraphRepository.prototype.index = function(nodesType, query, callback) {
      var cypher, paging, queryStr, ref;
      ref = makeQuery(query, 'n'), queryStr = ref[0], paging = ref[1];
      cypher = "MATCH (n:" + nodesType + ") " + queryStr + " RETURN n " + paging;
      console.log("Cypher: " + cypher);
      return this.run(cypher, {}, callback);
    };

    iGraphRepository.prototype.add = function(cypher, callback) {
      throw new Error('not implemented');
    };

    iGraphRepository.prototype.indexEdge = function(edgesType, query, callback) {
      var cypher, paging, queryStr, ref;
      ref = makeQuery(query, 'e'), queryStr = ref[0], paging = ref[1];
      cypher = "MATCH ()-[e:" + edgesType + "]->() " + queryStr + " RETURN e " + paging;
      console.log("Cypher: " + cypher);
      return this.run(cypher, {}, callback);
    };

    iGraphRepository.prototype.getEdge = function(example, callback) {
      var cypher;
      if (example.id === "" || example.id === null) {
        callback(null, "{}");
        return;
      }
      cypher = "MATCH ()-[n:" + example.type + "]->() WHERE n.id = {id} RETURN n LIMIT 1";
      console.log("Cypher: " + cypher);
      return this.run(cypher, example, callback);
    };

    iGraphRepository.prototype.setEdge = function(params, edge, callback) {
      var data, makeUpsert, ref, session, upsert;
      makeUpsert = (function(_this) {
        return function(params, data) {

          /*
              MATCH (a:Zip {id: '019'}), (b:LtlCode {id: '019_11000_200_300'})
              MERGE (a)-[r:ZIPLTL {id: '019_019_11000_200_300', cost: '34', kind:'LTL' }]->(b)
              ON CREATE SET r.created=timestamp()
              ON MATCH SET r.updated=timestamp()
           */
          var key, properties, propstring, upsertStatement, upsertString, value;
          if (!(data.id != null)) {
            data.id = uuid.v4();
          }
          propstring = ((function() {
            var results1;
            results1 = [];
            for (key in data) {
              value = data[key];
              results1.push("" + key + ":'" + value + "', ");
            }
            return results1;
          })()).reduce(function(t, s) {
            return t + s;
          });
          propstring = propstring.slice(0, -2);
          properties = ((function() {
            var results1;
            results1 = [];
            for (key in data) {
              value = data[key];
              results1.push("" + key + ":{" + key + "}, ");
            }
            return results1;
          })()).reduce(function(t, s) {
            return t + s;
          });
          properties = properties.slice(0, -2);
          upsertString = "MATCH " + "(a:" + params.sourcekind + " {id:'" + params.sourceid + "'}), " + "(b:" + params.destinationkind + " {id:" + params.destinationid + "}) " + "MERGE (a)-[r:" + params.kind + " {" + propstring + "}]->(b) " + "ON CREATE SET r.created=timestamp() " + "ON MATCH SET r.updated=timestamp()";
          upsertString = combyne(upsertString).render(params);
          upsertStatement = "MATCH " + "(a:" + params.sourcekind + " {id:{sourceid}}), " + "(b:" + params.destinationkind + " {id:{destinationid}}) " + "MERGE (a)-[r:" + params.kind + " {" + properties + "}]->(b) " + "ON CREATE SET r.created=timestamp() " + "ON MATCH SET r.updated=timestamp()";
          for (key in params) {
            value = params[key];
            data[key] = value;
          }
          return [data, upsertStatement];
        };
      })(this);
      ref = makeUpsert(params, edge), data = ref[0], upsert = ref[1];
      if ((this.buffer != null) || (callback == null)) {
        this.buffer.run(upsert, data);
      } else {
        session = this.neo4j.session();
        session.run(upsert, edge).then((function(_this) {
          return function(result) {
            session.close();
            return callback(null, result);
          };
        })(this))["catch"]((function(_this) {
          return function(error) {
            session.close();
            return callback(error, null);
          };
        })(this));
      }
    };

    iGraphRepository.prototype.set = function(id, obj, callback) {
      var data, makeUpsert, ref, session, upsert;
      makeUpsert = function(data) {
        var create, key, properties, update, upsertStatement, value;
        if (!(data.id != null)) {
          data.id = uuid.v4();
        }
        properties = ((function() {
          var results1;
          results1 = [];
          for (key in data) {
            value = data[key];
            results1.push("n." + key + " = {" + key + "}, ");
          }
          return results1;
        })()).reduce(function(t, s) {
          return t + s;
        });
        properties = properties.slice(0, -2);
        create = "n.created=timestamp(), " + properties;
        update = "n.updated=timestamp(), " + properties;
        upsertStatement = ("MERGE (n:" + data.type + " { id: {id} }) ON CREATE SET ") + create + " ON MATCH SET " + update;
        return [data, upsertStatement];
      };
      if ((id != null)) {
        obj.id = id;
      }
      ref = makeUpsert(obj), data = ref[0], upsert = ref[1];
      if ((this.buffer != null) || (callback == null)) {
        this.buffer.run(upsert, data);
      } else {
        session = this.neo4j.session();
        session.run(upsert, data).then((function(_this) {
          return function(result) {
            session.close();
            return callback(null, result);
          };
        })(this))["catch"]((function(_this) {
          return function(error) {
            session.close();
            return callback(error, null);
          };
        })(this));
      }
    };

    iGraphRepository.prototype["delete"] = function(id) {};

    iGraphRepository.prototype.pipeline = function() {
      this.session = this.neo4j.session();
      this.buffer = this.session.beginTransaction();
    };

    iGraphRepository.prototype.exec = function(callback) {
      return this.buffer.commit().subscribe({
        onCompleted: (function(_this) {
          return function() {
            _this.session.close();
            _this.buffer = null;
            callback(null, "success");
          };
        })(this),
        onError: (function(_this) {
          return function(error) {
            _this.session.close();
            _this.buffer = null;
            callback(error, null);
          };
        })(this)
      });
    };

    return iGraphRepository;

  })();

}).call(this);

//# sourceMappingURL=Neo4jRepository.js.map
